{"name":"snappy-java","tagline":"Snappy compressor/decompressor for Java","body":"The snappy-java is a Java port of the snappy\r\n<http://code.google.com/p/snappy/>, a fast C++ compresser/decompresser developed by Google.\r\n\r\n## Features \r\n  * [Apache License Version 2.0](http://www.apache.org/licenses/LICENSE-2.0). Free for both commercial and non-commercial use.\r\n  * Fast compression/decompression tailored to 64-bit CPU architecture. \r\n  * JNI-based implementation to achieve comparable performance to the native C++ version.  \r\n     * Although snappy-java uses JNI, it can be used safely with multiple class loaders (e.g. Tomcat, etc.). \r\n  * Portable across various operating systems; Snappy-java contains native libraries built for Window/Mac/Linux (32/64-bit). At runtime, snappy-java loads one of these libraries according to your machine environment (It looks system properties, `os.name` and `os.arch`). \r\n  * Simple usage. Add the snappy-java-(version).jar file to your classpath. Then call compression/decompression methods in org.xerial.snappy.Snappy. \r\n\r\n## Performance \r\n  * Snappy's main target is very high-speed compression/decompression with reasonable compression size. So the compression ratio of snappy-java is modest and about the same as `LZF` (ranging 20%-100% according to the dataset).\r\n\r\n  * Here are some [benchmark results](https://github.com/ning/jvm-compressor-benchmark/wiki), comparing\r\n snappy-java and the other compressors\r\n `LZO-java`/`LZF`/`QuickLZ`/`Gzip`/`Bzip2`. Thanks [Tatu Saloranta @cotowncoder](http://twitter.com/#!/cowtowncoder) for providing the benchmark suite. \r\n * The benchmark result indicates snappy-java is the fastest compreesor/decompressor in Java:\r\n    * <http://ning.github.com/jvm-compressor-benchmark/results/canterbury-roundtrip-2011-07-28/index.html>\r\n * The decompression speed is twice as fast as the others:\r\n    * <http://ning.github.com/jvm-compressor-benchmark/results/canterbury-uncompress-2011-07-28/index.html>\r\n\r\n\r\n## Download \r\nThe current stable version is available from here:\r\n  * Release version: http://code.google.com/p/snappy-java/downloads/list\r\n     * [Release plans](https://github.com/xerial/snappy-java/blob/develop/Milestone.md) \r\n  * Snapshot version (the latest beta version): https://oss.sonatype.org/content/repositories/snapshots/org/xerial/snappy/snappy-java/\r\nIf you are a Maven user, see [pom.xml example](#using-with-maven).\r\n\r\n## Usage \r\nFirst, import `org.xerial.snapy.Snappy` in your Java code:\r\n\r\n     import org.xerial.snappy.Snappy;\r\n\r\n\r\nThen use `Snappy.compress(byte[])` and `Snappy.uncompress(byte[])`:\r\n\r\n     String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper of \"\r\n     + \"Snappy, a fast compresser/decompresser.\";\r\n     byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\r\n     byte[] uncompressed = Snappy.uncompress(compressed);\r\n     \r\n     String result = new String(uncompressed, \"UTF-8\");\r\n     System.out.println(result);\r\n\r\n\r\nIn addition, high-level methods (`Snappy.compress(String)`, `Snappy.compress(float[] ..)` etc. ) and low-level ones (e.g. `Snappy.rawCompress(.. )`,  `Snappy.rawUncompress(..)`, etc.), which minimize memory copies, can be used. See also \r\n[Snappy.java](https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/Snappy.java)\r\n\r\n### Stream-based API\r\nStream-based compressor/decompressor `SnappyOutputStream`/`SnappyInputStream` are also available for reading/writing large data sets.\r\n\r\n### Setting classpath\r\nIf you have snappy-java-(VERSION).jar in the current directory, use `-classpath` option as follows:\r\n\r\n    $ javac -classpath \".;snappy-java-(VERSION).jar\" Sample.java  # in Windows\r\n    or \r\n    $ javac -classpath \".:snappy-java-(VERSION).jar\" Sample.java  # in Mac or Linux\r\n\r\n\r\n### Using with Maven\r\n  * Snappy-java is available from Maven's central repository:  <http://repo1.maven.org/maven2/org/xerial/snappy/snappy-java>\r\n\r\nAdd the following dependency to your pom.xml:\r\n\r\n    <dependency>\r\n      <groupId>org.xerial.snappy</groupId>\r\n      <artifactId>snappy-java</artifactId>\r\n      <version>(version)</version>\r\n      <type>jar</type>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n\r\n## Public discussion group\r\nPost bug reports or feature request to the Issue Tracker: <https://github.com/xerial/snappy-java/issues>\r\n\r\nPublic discussion forum is here: <http://groups.google.com/group/xerial?hl=en Xerial Public Discussion Group>\r\n\r\n\r\n## Building from the source code \r\nSee the [installation instruction](https://github.com/xerial/snappy-java/blob/develop/INSTALL). Building from the source code is an option when your OS platform and CPU architecture is not supported. To build snappy-java, you need Git, JDK (1.6 or higher), Maven (3.x or higher is required), g++ compiler (mingw in Windows) etc.\r\n\r\n    $ git clone https://github.com/xerial/snappy-java.git\r\n    $ cd snappy-java\r\n    $ make\r\n    \r\n\r\nA file `target/snappy-java-$(version).jar` is the product additionally containing the native library built for your platform.\r\n\r\n## Cross-compiling for other platforms\r\nThe Makefile contains rules for cross-compiling the native library for other platforms so that the snappy-java JAR can support multiple platforms. For example, to build the native libraries for x86 Linux, x86 and x86-64 Windows, and soft- and hard-float ARM:\r\n\r\n    $ make linux32 win32 win64 linux-arm linux-armhf\r\n\r\nIf you append `snappy` to the line above, it will also build the native library for the current platform and then build the snappy-java JAR (containing all native libraries built so far).\r\n\r\nOf course, you must first have the necessary cross-compilers and development libraries installed for each target CPU and OS. For example, on Ubuntu 12.04 for x86-64, install the following packages for each target:\r\n\r\n  * linux32: `sudo apt-get install g++-multilib libc6-dev-i386 lib32stdc++6`\r\n  * win32: `sudo apt-get install g++-mingw-w64-i686`\r\n  * win64: `sudo apt-get install g++-mingw-w64-x86-64`\r\n  * arm: `sudo apt-get install g++-arm-linux-gnueabi`\r\n  * armhf: `sudo apt-get install g++-arm-linux-gnueabihf`\r\n\r\nUnfortunately, cross-compiling for Mac OS X is not currently possible; you must compile within OS X.\r\n\r\nIf you are using Mac and openjdk7 (or higher), use the following option:\r\n\r\n    $ make native LIBNAME=libsnappyjava.dylib\r\n\r\n## Miscellaneous Notes\r\n### Using snappy-java with Tomcat 6 (or higher) Web Server\r\n\r\nSimply put the snappy-java's jar to WEB-INF/lib folder of your web application. Usual JNI-library specific problem no longer exists since snappy-java version 1.0.3 or higher can be loaded by multiple class loaders in the same JVM by using native code injection to the parent class loader (Issue 21). \r\n\r\n----\r\nSnappy-java is developed by [Taro L. Saito](http://www.xerial.org/leo). Twitter  [@taroleo](http://twitter.com/#!/taroleo)\r\n","google":"UA-59666-9","note":"Don't delete this file! It's used internally to help with page regeneration."}